<!DOCTYPE HTML>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8" />

	<title>Project Portfolio</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0" /><!-- Bootstrap -->
	<link href="css/bootstrap.min.css" rel="stylesheet" media="screen" type="text/css" />
	<link href="css/custom.css" rel="stylesheet" media="screen" type="text/css" /><!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
	<!--[if lt IE 9]>
	  <script src="../assets/js/html5shiv.js"></script>
  	<![endif]-->
</head>

<body>
	<div id="wrap">
		<div class="container">
			<div class="row">
				<div class="span12 pagination-centered">
					<h1><a href="index.html">Project Portfolio</a></h1>
				</div></div>

				<div class="row">
					<div class="span12" id="pixiContainer"></div>
				</div>
        <div class="row">
          <div class="span12">
            <center><small>Click on two road segments to find a path between them.</small></center>
          </div>
        </div>
        <div class="row">
          <div class="span12">
            <p class="nice">Since seeing the city generation from the shelved Introversion Software game "Subversion" <a href="https://www.youtube.com/watch?v=J30i0gABfS8">in action</a>, I've wanted to to try writing a basic procedural city generator myself. The developers followed a method described in <a href="https://graphics.ethz.ch/Downloads/Publications/Papers/2001/p_Par01.pdf">Parish and Müller's paper: Procedural Modelling of Cities (2001)</a>. The paper is well-written and accessible, apart from the authors' decision to define their algorithm as an L-system. The rules defined for the system are hard to interpret for a layperson and, as argued by <a href="http://mollyrocket.com/forums/viewtopic.php?t=730">one forum thread author</a>,<sup><a href="#fn1" id="ref1">1</a></sup> can be transformed into <a href="http://www.newton64.ca/blog/?p=747">an equivalent but more familiar form</a>. The demonstration above is the result of implementing this form of the algorithm with some of the 'global goals' and 'local goals' suggested by Parish and Müller. Pathfinding has also been added to this example.</p>
            <p class="nice">Source for the main parts of the algorithm can be found here. <strong>Put dependencies on readme page.</strong></p>
            <h2>Algorithm</h2>
            <p class="nice">The posts mentioned above do a good job of explaining the general form of the algorithm. The original pseudo-code from the linked forum thread is:
            <pre><code>
            initialize priority queue Q with a single entry: r(0, r0, q0)
            initialize segment list S to empty
            
            until Q is empty
              pop smallest r(ti, ri, qi) from Q (i.e., smallest ‘t’)
              accepted = localConstraints(&r)
              if (accepted) {
                add segment(ri) to S
                foreach r(tj, rj, qj) produced by globalGoals(ri, qi)
                  add r(ti + 1 + tj, rj, qj) to Q
              }
              </code></pre>
            <p class="nice"><code>r</code> is a road segment with parameters <code>ti</code>, the time delay until the segment is placed in the world, <code>ri</code>, the geometrical properties of the segment, and <code>qi</code>, any additional metadata associated with the segment. <code>Q</code> is a list of segments yet to be placed in the world. In each iteration of the algorithm the segment with the smallest <code>ti</code> is removed from <code>Q</code>. <code>localConstraints</code> checks the segment for compatibility with all previously placed segments and may modify its geometry if necessary, for example to join the end of the segment to a nearby junction.</p>
            <p class="nice">If the segment is found to be compatible, it is added to the list of placed segments <code>S</code>. The newly placed segment is then fed into <code>globalGoals</code> which decides what, if any, new segments should branch out from it in the future. The implementation of globalGoals is entirely up to the developer: I made the decision for roads to simply tend towards areas of high population density. The original authors added further constraints to create several distinctive categories of road patterns.</p>
            <p class="nice">The behaviour of the algorithm can be visualised by turning on the debug view in the demonstration above. The highlighted path shows the order that segments are placed. Segments can be seen branching out from the main highways, and merging with parallel areas of growth as dictated by the local constraints. The consequence of queueing the segments by <code>ti</code> can also be seen, as the network grows roughly uniformly across its circumference and no dangling segment remains inactive for long.</p>
            <h2>Population Density</h2>
            <p class="nice">In the </p>
            <h2>Building Placement</h2>
            <p class="nice">In the example above the <a href="http://www.metanetsoftware.com/technique/tutorialA.html#section2">separating axis theorem</a> is used for collision detection, specifically to disperse buildings among the road network. The initial position of each building is randomly selected. To determine the final position of a building it's moved away from any overlapping roads or existing buildings along the direction of minimum overlap. If the building is still not in the clear after a fixed number of iterations it's discarded.</p>
            <h2>Pathfinding</h2>
            <p class="nice">I've used the venerable A* algorithm for pathfinding, with Amit Patel's <a href="http://www.redblobgames.com/pathfinding/a-star/introduction.html">excellent guide</a> as background reading. During the generation process, each road segment is associated with those segments which connect directly to either end of it, allowing the network of segments to be traversed.</p>
            <p class="nice">The cost of each segment is the time to travel along it, a function of its length and the maximum allowed speed. Playing around with the pathfinding in the demonstration above, you may notice that the highway segments, which have a higher maximum speed, are preferred over normal road segments. The speed is in turn a function of the capacity of the road i.e. the traffic currently using the road, and although all roads are currently defined as empty, the pathfinder has the ability to avoid busier roads.</p>
            <sup id="fn1">1. The forum post is currently unavailable, but has been temporarily transferred <a href="https://mollyrocket.com/forums/molly_forum_730.html">here</a> in a fairly unreadable form. <a href="#ref1" title="Back to footnote 1."><small>↑</small></a></sup>
          </div>
        </div>

			<div id="push">&nbsp;</div>
		</div>

		<div id="footer">
			<div class="row container">
        <div class="span12 pagination-centered">
  				<p class="muted credit">
  					<a
  class='email
  href="mailto:x@y"
  '
  href
   =	'	
  &#x20;&#x6D;a&#x69;lt&#x6F;&#x3a;%&#50;&#x30;%&#x36;&#x33;&#37;6f&#x6e;%&#x37;4%6&#49;&#x63;t&#x25;&#x34;0&#x25;&#x37;&#x34;%&#x36;d&#x77;%&#x36;8%6&#x35;&#x72;%6&#53;&#x25;&#x32;&#x65;&#x25;&#54;&#x33;&#37;6f&#x6d;&#x3F;
  '><!--
  mailto:abuse@hotmail.com
  </a>
  --><img class="small-social" src="img/mail_nobg.png"/></a> <a href="http://twitter.com/tobmansf"><img class="small-social" src="img/twitter_nobg.png"/></a>
  				</p>
        </div>
			</div>
		</div>

		<div id="myModal" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
			<div class="modal-header">
				<span class="modal-header-name">reserved</span> <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&#215;</button>
			</div>

			<div class="modal-body">
			</div>
		</div>
		<script src="http://code.jquery.com/jquery.js" type="text/javascript"></script>
		<script src="js/bootstrap.min.js" type="text/javascript"></script>
    <script src="js/road_generation.js"></script>
</body>
</html>
